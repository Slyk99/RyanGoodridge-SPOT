function [xStack, PStack, NAVout] = EstimateStates(xStack, PStack, u, dt, zGNS, zINS_full, navOpts)
    %% Inputs
    params = navOpts.params;
    persistent Q_INS Q_GNS Q_12 RINSfull R_GNS ...
    r_LRF r_IMU r_Lidar r_Stereo r_PS alphaSH rho_GNS rho_INS V_INS V_GNS initialized

    if isempty(initialized)
        Q_INS       = navOpts.Q_INS;    Q_GNS       = navOpts.Q_GNS; 
        Q_12        = navOpts.Q_12;     R_GNS       = navOpts.R_GNS;    
        RINSfull    = navOpts.RINSfull;

        r_PS        = navOpts.r_PS;     r_LRF       = navOpts.r_LRF;
        r_Stereo    = navOpts.r_Stereo; r_Lidar     = navOpts.r_Lidar;
        r_IMU       = navOpts.r_IMU;    alphaSH     = navOpts.alphaSH; 
        
        rho_GNS  = navOpts.rho.GNS;
        rho_INS  = navOpts.rho.INS;
        V_INS    = zeros(6);
        V_GNS    = zeros(5);

        initialized = true;         
    end

    %% Define Function shorthand
    dynHandle    = @(x, dt, u) TempFilterModule.OrbitEstimation.Propagation.Euler1_propagate(x, dt, u, params);
    INSHandle    = @(x) TempFilterModule.OrbitEstimation.Measurements.INS(x);
    GNSHandle    = @(x) TempFilterModule.OrbitEstimation.Measurements.GNS(x);
    FilterHandle = @(z, x, u, P, Q, R, V, rho, H_Handle) TempFilterModule.OrbitEstimation.Filter.UDU_STEKF(dt, ...
                     z, x, u, P, Q, R, V, rho, H_Handle, ...
                     dynHandle, navOpts.ST, navOpts.OLR, navOpts.dmax);

    %% Unpack data
    [x_INS, P_INS, x_GNS, P_GNS, ~, P12] = TempFilterModule.Misc.unpackStates(xStack, PStack);

    %% Add Bias
    zGNS = zGNS + r_PS;
    zINS_full = zINS_full + [r_Stereo; r_Lidar; r_LRF; ];

    %% Preallocate Space
    % EKF_INS output
    m_max = 6;
    EKF_INS.y  = zeros(m_max,1); 
    EKF_INS.K  = zeros(length(x_INS),m_max);
    EKF_INS.H  = zeros(m_max,length(x_INS));
    EKF_INS.xk = x_INS;
    EKF_INS.Pk = P_INS;
    EKF_INS.F  = zeros(8);
    EKF_INS.G  = zeros(8,4);
    EKF_INS.V  = V_INS;
    EKF_INS.d  = 0;

    m_PS       = 5;
    EKF_GNS.y  = zeros(m_PS,1); 
    EKF_GNS.K  = zeros(length(x_INS),m_PS);
    EKF_GNS.H  = zeros(m_PS,length(x_INS));
    EKF_GNS.xk = x_GNS;
    EKF_GNS.Pk = P_GNS;
    EKF_GNS.F  = zeros(8);
    EKF_GNS.G  = zeros(8,4);
    EKF_GNS.V  = V_GNS;
    EKF_GNS.d  = 0;

    %% Inertial Navigation Filter
    if navOpts.INStoggle
        % Sensor fusion
        [zINS,R_INS] = TempFilterModule.OrbitEstimation.Measurements.fusion(zINS_full, RINSfull);

        % INS Filter 
        [x_INS, P_INS, EKF_INS] = FilterHandle(zINS, x_INS, u, P_INS, Q_INS, R_INS, V_INS, rho_INS, INSHandle);
         V_INS = EKF_INS.V;

    end % end INS Toggle

    %% GNS Filter
    if navOpts.GNStoggle
        [x_GNS, P_GNS, EKF_GNS] = FilterHandle(zGNS, x_GNS, u, P_GNS, Q_GNS, R_GNS, V_GNS, rho_GNS, GNSHandle);
        V_GNS = EKF_GNS.V;

    end % End GNS Toggle 

    %% Track 2 Track Fusion - Assumes GNS has a more accurate F and G
    if navOpts.GNStoggle && navOpts.INStoggle
        [x12, P12] = TempFilterModule.Fusion.Track2Track(x_INS, P_INS, EKF_INS.K, EKF_INS.H, ...
         x_GNS, P_GNS, EKF_GNS.K, EKF_GNS.H, ...
         P12, Q_12, EKF_GNS.F, EKF_GNS.G);

    elseif navOpts.INStoggle % Keep x12 as best estimate no matter what is selected
        x12 = x_INS;

        % UD is n-by-n combined matrix
        n = size(P_INS,1);
        idx = 1:(n+1):n*n;        % linear indices of diagonal entries

        dvec = P_INS(idx);          % extract diagonal as vector
        D = diag(dvec);          % full diagonal matrix (optional)
        U = P_INS;                  
        U(idx) = 1;              % set diagonal to ones -> unit upper triangular U
        P12 = U*D*U';
    else
        x12 = x_GNS;
        % UD is n-by-n combined matrix
        n = size(P_GNS,1);
        idx = 1:(n+1):n*n;        % linear indices of diagonal entries

        dvec = P_GNS(idx);          % extract diagonal as vector
        D = diag(dvec);          % full diagonal matrix (optional)
        U = P_GNS;                  
        U(idx) = 1;              % set diagonal to ones -> unit upper triangular U
        P12 = U*D*U';
    end % end Track 2 Track

    %% Run Sage Husa main
    [RINSfull, R_GNS, ...
        r_PS, r_LRF, r_Stereo, r_Lidar, r_IMU, ...
        Q_INS, Q_GNS, SageHusa] = TempFilterModule.AdaptiveLaws.SageHusa_main( ...
        navOpts, alphaSH, ...
        EKF_INS, EKF_GNS, ...
        Q_INS, Q_GNS, ...
        RINSfull, R_GNS, ...
        r_PS, r_LRF, r_Stereo, r_Lidar, r_IMU, ...
        zGNS, zINS_full, ...
        x12, GNSHandle, INSHandle);

    %% Filter Output
    NAVout.EKF_GNS    = EKF_GNS;
    NAVout.EKF_INS    = EKF_INS;
    NAVout.SageHusa   = SageHusa;

    [xStack, PStack]  = TempFilterModule.Misc.packStates(x_INS, P_INS, x_GNS, P_GNS, x12, P12);

end

